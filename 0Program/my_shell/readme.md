## MY_Shell

dup和dup2也是两个非常有用的调用，它们的作用都是用来复制一个文件的描述符。它们经常用来重定向进程的stdin、stdout和stderr。这两个函数的原形如下：
### dup()函数


利用函数dup，我们可以复制一个描述符。传给该函数一个既有的描述符，它就会返回一个新的描述符，这个新的描述符是传给它的描述符的拷贝。这意味着，这两个描述符共享同一个数据结构。例如，如果我们对一个文件描述符执行lseek操作，得到的第一个文件的位置和第二个是一样的。

 需要注意的是，我们可以在调用fork之前建立一个描述符，这与调用dup建立描述符的效果是一样的，子进程也同样会收到一个复制出来的描述符。 

### dup2()函数

 

dup2函数跟dup函数相似，但dup2函数允许调用者规定一个有效描述符和目标描述符的id。dup2函数成功返回时，目标描述符（dup2函数的第二个参数）将变成源描述符（dup2函数的第一个参数）的复制品，换句话说，两个文件描述符现在都指向同一个文件，并且是函数第一个参数指向的文件。




### waitpid()
pid_t waitpid(pid_t pid, int *status, int options);

### 参数：
pid>0	只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。
pid=-1	等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。
pid=0时	等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
pid<-1	等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。
* 参数status如果不是一个空指针,则终止进程的终止状态就存放在status所指向的单元。 
* 参数status如果是一个空指针,则表示父进程不关心子进程的终止状态

option

WNOHANG	若由pid指定的子进程未发生状态改变(没有结束)，则waitpid()不阻塞，立即返回0
WUNTRACED	返回终止子进程信息和因信号停止的子进程信息
WCONTINUED	返回收到SIGCONT信号而恢复执行的已停止子进程状态信息
返回值：

成功	成功结束运行的子进程的进程号
失败	返回-1
WNOHANG	没有子进程退出返回0

